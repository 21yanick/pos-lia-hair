import React from 'react'
import type { ReconciliationData } from '@/shared/services/reconciliationService'
import type { ExportData, MonthlyStatsData } from '@/shared/types/monthly'
import type { TransactionItem } from '@/shared/types/transactions'
import { formatDateForDisplay, getTodaySwissString } from './dateUtils'
import { formatMonthYear } from './reportHelpers'

// CSV Export functionality
export function exportToCSV(data: ExportData): void {
  const { type, label, transactions, selectedMonth } = data

  let csvContent = `${label} - ${formatMonthYear(selectedMonth)}\n`
  csvContent += `Exportiert am: ${formatDateForDisplay(getTodaySwissString())}\n\n`

  // Header für neue TransactionItem Struktur
  csvContent += 'Datum,Typ,Beschreibung,Betrag,Zahlungsart,Status\n'

  // Daten hinzufügen
  transactions.forEach((transaction) => {
    const date = formatDateForDisplay(transaction.date)
    const sign = transaction.amount < 0 ? '-' : ''
    const typeLabel =
      transaction.type === 'sale'
        ? 'Verkauf'
        : transaction.type === 'expense'
          ? 'Ausgabe'
          : transaction.type === 'bank_deposit'
            ? 'Bankeinzahlung'
            : 'Unbekannt'

    csvContent += `${date},"${typeLabel}","${transaction.description || ''}",${sign}${Math.abs(transaction.amount)},${transaction.method},${transaction.status}\n`
  })

  // CSV-Datei herunterladen
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  const url = window.URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `${label.toLowerCase().replace(/\s+/g, '_')}_${selectedMonth}.csv`
  a.click()
  window.URL.revokeObjectURL(url)
}

// PDF Export für kompletten Monat (moderne React-PDF Version)
export async function exportMonthlyPDF(
  stats: MonthlyStatsData,
  transactions: TransactionItem[],
  selectedMonth: string,
  autoGenerated = false
): Promise<void> {
  try {
    // Dynamischer Import für PDF-Komponente und Services
    const { MonthlyReportPDF } = await import('@/shared/components/pdf/MonthlyReportPDF')
    const { getReconciliationData } = await import('@/shared/services/reconciliationService')
    const { getBusinessSettings, resolveLogoUrl } = await import(
      '@/shared/services/businessSettingsService'
    )

    // Parallel loading von Business Settings und Reconciliation Data
    const [businessSettings, reconciliationData] = await Promise.all([
      getBusinessSettings().catch((_err) => {
        // console.warn('Failed to load business settings for PDF:', err)
        return null
      }),
      getReconciliationData(selectedMonth).catch((_err) => {
        // console.warn('Failed to load reconciliation data for PDF:', err)
        return null
      }),
    ])

    // Logo URL für PDF-Kontext auflösen (Development: localhost -> Docker-interne URL)
    const resolvedBusinessSettings = businessSettings
      ? {
          ...businessSettings,
          logo_url: resolveLogoUrl(businessSettings.logo_url),
        }
      : null

    const pdfComponent = React.createElement(MonthlyReportPDF, {
      stats,
      selectedMonth,
      businessSettings: resolvedBusinessSettings,
      reconciliationData,
    })

    // PDF direkt mit react-pdf erstellen
    const { pdf } = await import('@react-pdf/renderer')
    const blob = await pdf(pdfComponent as any).toBlob() // Type assertion to fix TS error
    const fileName = `monatsabschluss-${selectedMonth}.pdf`
    const file = new File([blob], fileName, { type: 'application/pdf' })

    // Datei zu Supabase Storage hochladen
    const { supabase } = await import('@/shared/lib/supabase/client')
    const filePath = `documents/monthly_reports/${fileName}` // Removed duplicate 'documents'

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: true,
      })

    if (uploadError) {
      // console.error('❌ Fehler beim Hochladen der Monthly PDF:', uploadError)
      // Skip storage upload and database entry, go directly to download
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = fileName
      a.click()
      window.URL.revokeObjectURL(url)
      return
    }

    // Dokument-Eintrag in der Datenbank erstellen
    const { data: userData } = await supabase.auth.getUser()
    if (!userData?.user) {
      // Still provide download even if we can't save to database
      const { data: urlData } = supabase.storage.from('documents').getPublicUrl(filePath)

      window.open(urlData.publicUrl, '_blank')
      return
    }

    const monthDate = `${selectedMonth}-01`
    const monthlyUUID = crypto.randomUUID()

    const documentData = {
      type: 'monthly_report' as const,
      reference_id: monthlyUUID,
      file_path: filePath,
      file_name: fileName,
      payment_method: null,
      document_date: monthDate,
      user_id: userData.user.id,
    }

    const { error: documentError } = await supabase.from('documents').upsert(documentData)

    if (documentError) {
      // console.error('❌ Fehler beim Erstellen des Monthly Document-Eintrags:', documentError)
      // Even if database entry fails, we can still open the uploaded file
      const { data: urlData } = supabase.storage.from('documents').getPublicUrl(filePath)

      window.open(urlData.publicUrl, '_blank')
      return
    }

    // PDF nur öffnen wenn nicht automatisch generiert
    if (!autoGenerated) {
      const { data: urlData } = supabase.storage.from('documents').getPublicUrl(filePath)

      window.open(urlData.publicUrl, '_blank')
    }
  } catch (error: any) {
    console.error('❌ Fehler beim Erstellen der Monthly PDF:', error)

    // Fallback: Manueller Download - aber PDF erstellen funktioniert
    try {
      const blob = await createFallbackPDF(stats, transactions, selectedMonth)
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `monatsabschluss-${selectedMonth}.pdf`
      a.click()
      window.URL.revokeObjectURL(url)
    } catch (fallbackError) {
      console.error('❌ Even fallback failed:', fallbackError)
      alert('PDF-Generierung fehlgeschlagen. Bitte versuchen Sie es später erneut.')
    }
  }
}

// PDF für bestimmten Monat öffnen/downloaden
export async function openMonthlyPDF(selectedMonth: string): Promise<void> {
  try {
    const { supabase } = await import('@/shared/lib/supabase/client')

    // Prüfen ob PDF bereits existiert
    const fileName = `monatsabschluss-${selectedMonth}.pdf`
    const _filePath = `documents/monthly_reports/${fileName}`

    // Erst in der documents table suchen
    const monthDate = `${selectedMonth}-01`
    const { data: documentData, error: documentError } = await supabase
      .from('documents')
      .select('file_path')
      .eq('type', 'monthly_report')
      .eq('document_date', monthDate)
      .single()

    if (documentData && !documentError) {
      // PDF existiert in Datenbank, versuche es zu öffnen

      const { data: urlData } = supabase.storage
        .from('documents')
        .getPublicUrl(documentData.file_path)

      if (urlData.publicUrl) {
        window.open(urlData.publicUrl, '_blank')
        return
      }
    }

    // PDF existiert nicht, weiterleiten zur Documents-Seite
    window.open(`/documents?month=${selectedMonth}`, '_blank')
  } catch (error: any) {
    console.error('❌ Fehler beim Öffnen des PDFs:', error)
    // Fallback: Documents-Seite öffnen
    window.open(`/documents?month=${selectedMonth}`, '_blank')
  }
}

// Hauptexport-Funktion
export async function handleExport(data: ExportData): Promise<void> {
  const { type } = data

  if (type === 'complete_month') {
    // Für kompletten Monat PDF erstellen
    await exportMonthlyPDF(data.stats, data.transactions, data.selectedMonth)
  } else {
    // Für spezifische Exports CSV erstellen
    exportToCSV(data)
  }
}

// Fallback-Funktion für direkten Download (vereinfacht)
async function createFallbackPDF(
  stats: MonthlyStatsData,
  _transactions: TransactionItem[],
  selectedMonth: string
): Promise<Blob> {
  // Dynamischer Import für React-PDF
  const { pdf } = await import('@react-pdf/renderer')
  const { MonthlyReportPDF } = await import('@/shared/components/pdf/MonthlyReportPDF')

  const pdfComponent = React.createElement(MonthlyReportPDF, {
    stats,
    selectedMonth,
  })

  return await pdf(pdfComponent as any).toBlob() // Type assertion to fix TS error
}

// PDF Export mit bereits geladenen reconciliationData (für ReconciliationReportTab)
export async function exportMonthlyPDFWithReconciliation(
  stats: MonthlyStatsData,
  selectedMonth: string,
  reconciliationData: ReconciliationData,
  autoGenerated = false
): Promise<void> {
  try {
    // Dynamischer Import für PDF-Komponente und Services
    const { MonthlyReportPDF } = await import('@/shared/components/pdf/MonthlyReportPDF')
    const { getBusinessSettings } = await import('@/shared/services/businessSettingsService')

    // Nur Business Settings laden (reconciliationData bereits vorhanden)
    const businessSettings = await getBusinessSettings().catch((_err) => {
      // console.warn('Failed to load business settings for PDF:', err)
      return null
    })

    const pdfComponent = React.createElement(MonthlyReportPDF, {
      stats,
      selectedMonth,
      businessSettings,
      reconciliationData, // Use the passed data!
    })

    // PDF direkt mit react-pdf erstellen
    const { pdf } = await import('@react-pdf/renderer')
    const blob = await pdf(pdfComponent as any).toBlob()
    const fileName = `monatsabschluss-${selectedMonth}.pdf`
    const file = new File([blob], fileName, { type: 'application/pdf' })

    // Datei zu Supabase Storage hochladen
    const { supabase } = await import('@/shared/lib/supabase/client')
    const filePath = `documents/monthly_reports/${fileName}`

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: true,
      })

    if (uploadError) {
      // console.error('❌ Fehler beim Hochladen der Reconciliation PDF:', uploadError)
      // Direct download fallback
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = fileName
      a.click()
      window.URL.revokeObjectURL(url)
      return
    }

    // Dokument-Eintrag in der Datenbank erstellen
    const { data: userData } = await supabase.auth.getUser()
    if (!userData?.user) {
      const { data: urlData } = supabase.storage.from('documents').getPublicUrl(filePath)

      window.open(urlData.publicUrl, '_blank')
      return
    }

    const monthDate = `${selectedMonth}-01`
    const monthlyUUID = crypto.randomUUID()

    const documentData = {
      type: 'monthly_report' as const,
      reference_id: monthlyUUID,
      file_path: filePath,
      file_name: fileName,
      payment_method: null,
      document_date: monthDate,
      user_id: userData.user.id,
    }

    const { error: documentError } = await supabase.from('documents').upsert(documentData)

    if (documentError) {
      // console.error('❌ Fehler beim Erstellen des Document-Eintrags:', documentError)
      // Still open the uploaded file
      const { data: urlData } = supabase.storage.from('documents').getPublicUrl(filePath)

      window.open(urlData.publicUrl, '_blank')
      return
    }

    // PDF nur öffnen wenn nicht automatisch generiert
    if (!autoGenerated) {
      const { data: urlData } = supabase.storage.from('documents').getPublicUrl(filePath)

      window.open(urlData.publicUrl, '_blank')
    }
  } catch (error: any) {
    console.error('❌ Fehler beim Erstellen der Reconciliation PDF:', error)
    alert('PDF-Generierung fehlgeschlagen. Bitte versuchen Sie es später erneut.')
  }
}
