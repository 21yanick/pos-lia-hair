import { PDFDocument, StandardFonts, rgb } from 'pdf-lib'
import { supabase } from '@/lib/supabase/client'
import { formatDateForDisplay, formatTimeForDisplay } from '@/lib/utils/dateUtils'
import type { DailySummary, TransactionItem, DailyStatsData } from './dailyTypes'

// PDF-Generierung f√ºr Daily Reports
export async function generateDailyReportPDF(
  summary: DailySummary,
  transactions: TransactionItem[],
  autoGenerated = false
): Promise<{ success: boolean; error?: string; filePath?: string }> {
  console.log("üîß generateDailyReportPDF gestartet", { 
    summaryId: summary.id, 
    autoGenerated, 
    transactionCount: transactions.length 
  })
  
  try {
    // PDF-Dokument erstellen
    const pdfDoc = await PDFDocument.create()
    const page = pdfDoc.addPage([595.28, 841.89]) // A4
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica)
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold)
    
    const { width, height } = page.getSize()
    const fontSize = 12
    const padding = 50
    
    let yPos = height - padding

    // Titel
    page.drawText('TAGESABSCHLUSS', {
      x: padding,
      y: yPos,
      size: 24,
      font: boldFont,
      color: rgb(0, 0, 0),
    })
    yPos -= 50

    // Datum
    page.drawText(`Datum: ${formatDateForDisplay(summary.report_date)}`, {
      x: padding,
      y: yPos,
      size: fontSize + 2,
      font: boldFont,
      color: rgb(0, 0, 0),
    })
    yPos -= 30

    // Report ID
    page.drawText(`Bericht-ID: ${summary.id}`, {
      x: padding,
      y: yPos,
      size: fontSize,
      font,
      color: rgb(0, 0, 0),
    })
    yPos -= 40

    // Ums√§tze nach Zahlungsart
    page.drawText('UMS√ÑTZE NACH ZAHLUNGSART', {
      x: padding,
      y: yPos,
      size: fontSize + 2,
      font: boldFont,
      color: rgb(0, 0, 0),
    })
    yPos -= 25

    page.drawText(`Bar:     CHF ${summary.sales_cash.toFixed(2)}`, {
      x: padding + 20,
      y: yPos,
      size: fontSize,
      font,
      color: rgb(0, 0, 0),
    })
    yPos -= 20

    page.drawText(`TWINT:   CHF ${summary.sales_twint.toFixed(2)}`, {
      x: padding + 20,
      y: yPos,
      size: fontSize,
      font,
      color: rgb(0, 0, 0),
    })
    yPos -= 20

    page.drawText(`SumUp:   CHF ${summary.sales_sumup.toFixed(2)}`, {
      x: padding + 20,
      y: yPos,
      size: fontSize,
      font,
      color: rgb(0, 0, 0),
    })
    yPos -= 30

    page.drawText(`TOTAL:   CHF ${summary.sales_total.toFixed(2)}`, {
      x: padding + 20,
      y: yPos,
      size: fontSize + 2,
      font: boldFont,
      color: rgb(0, 0, 0),
    })
    yPos -= 50

    // Bargeld-Bestand
    page.drawText('BARGELD-BESTAND', {
      x: padding,
      y: yPos,
      size: fontSize + 2,
      font: boldFont,
      color: rgb(0, 0, 0),
    })
    yPos -= 25

    page.drawText(`Anfangsbestand: CHF ${summary.cash_starting.toFixed(2)}`, {
      x: padding + 20,
      y: yPos,
      size: fontSize,
      font,
      color: rgb(0, 0, 0),
    })
    yPos -= 20

    page.drawText(`+ Bareinnahmen: CHF ${summary.sales_cash.toFixed(2)}`, {
      x: padding + 20,
      y: yPos,
      size: fontSize,
      font,
      color: rgb(0, 0, 0),
    })
    yPos -= 20

    page.drawText(`Endbestand:     CHF ${summary.cash_ending.toFixed(2)}`, {
      x: padding + 20,
      y: yPos,
      size: fontSize + 2,
      font: boldFont,
      color: rgb(0, 0, 0),
    })
    yPos -= 30

    if (summary.cash_difference !== 0) {
      const differenceColor = summary.cash_difference > 0 ? rgb(0, 0.5, 0) : rgb(0.8, 0, 0)
      page.drawText(`Differenz:      CHF ${summary.cash_difference.toFixed(2)}`, {
        x: padding + 20,
        y: yPos,
        size: fontSize,
        font: boldFont,
        color: differenceColor,
      })
      yPos -= 30
    }

    // Transaktionsliste
    if (transactions.length > 0) {
      page.drawText('TRANSAKTIONEN', {
        x: padding,
        y: yPos,
        size: fontSize + 2,
        font: boldFont,
        color: rgb(0, 0, 0),
      })
      yPos -= 25

      // Header
      page.drawText('Zeit    Zahlungsart    Betrag', {
        x: padding + 20,
        y: yPos,
        size: fontSize,
        font: boldFont,
        color: rgb(0, 0, 0),
      })
      yPos -= 20

      // Transaktionen (maximal 30 f√ºr PDF)
      transactions.slice(0, 30).forEach((transaction) => {
        const methodText = transaction.method === 'cash' ? 'Bar' :
                         transaction.method === 'twint' ? 'TWINT' : 'SumUp'
        page.drawText(`${transaction.time}   ${methodText.padEnd(8)}     CHF ${transaction.amount.toFixed(2)}`, {
          x: padding + 20,
          y: yPos,
          size: fontSize - 1,
          font,
          color: rgb(0, 0, 0),
        })
        yPos -= 16
      })

      if (transactions.length > 30) {
        yPos -= 10
        page.drawText(`... und ${transactions.length - 30} weitere Transaktionen`, {
          x: padding + 20,
          y: yPos,
          size: fontSize - 1,
          font,
          color: rgb(0.5, 0.5, 0.5),
        })
      }
    }

    // Notizen
    if (summary.notes) {
      yPos -= 20
      page.drawText('NOTIZEN', {
        x: padding,
        y: yPos,
        size: fontSize + 2,
        font: boldFont,
        color: rgb(0, 0, 0),
      })
      yPos -= 25

      page.drawText(summary.notes, {
        x: padding + 20,
        y: yPos,
        size: fontSize,
        font,
        color: rgb(0, 0, 0),
      })
    }

    // Footer
    const now = new Date()
    page.drawText(`Erstellt am: ${now.toLocaleDateString('de-CH')} um ${now.toLocaleTimeString('de-CH')}`, {
      x: padding,
      y: 50,
      size: fontSize - 2,
      font,
      color: rgb(0.5, 0.5, 0.5),
    })

    // PDF speichern und hochladen
    console.log("üìÑ PDF-Dokument erstellt, speichere...")
    const pdfBytes = await pdfDoc.save()
    const fileName = `tagesabschluss-${summary.report_date}.pdf`
    const file = new File([pdfBytes], fileName, { type: 'application/pdf' })
    
    // Datei zu Supabase Storage hochladen
    const filePath = `documents/daily_reports/${fileName}`
    console.log("‚òÅÔ∏è Lade PDF zu Storage hoch:", filePath)
    
    const { error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: true // √úberschreiben falls bereits vorhanden
      })
      
    if (uploadError) {
      console.error('Fehler beim Hochladen der PDF:', uploadError)
      
      if (!autoGenerated) {
        // Fallback: Direkter Download ohne Storage
        const blob = new Blob([pdfBytes], { type: 'application/pdf' })
        const url = window.URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = fileName
        a.click()
        window.URL.revokeObjectURL(url)
      }
      
      return { success: false, error: uploadError.message }
    }

    // Dokument-Eintrag in der Datenbank erstellen/aktualisieren
    console.log("üóÉÔ∏è Erstelle Dokument-Eintrag in Datenbank...")
    const { data: userData } = await supabase.auth.getUser()
    if (userData?.user) {
      const documentData = {
        type: 'daily_report',
        reference_id: summary.id,
        file_path: filePath,
        payment_method: null,
        document_date: summary.report_date,
        user_id: userData.user.id
      }
      console.log("üìù Dokument-Daten:", documentData)
      
      const { error: documentError } = await supabase
        .from('documents')
        .upsert(documentData)
      
      if (documentError) {
        console.error('‚ùå Fehler beim Erstellen des Dokumenteneintrags:', documentError)
      } else {
        console.log("‚úÖ Dokument-Eintrag erfolgreich erstellt")
      }
    } else {
      console.error("‚ùå Kein User gefunden f√ºr Dokument-Erstellung")
    }

    // PDF nur √∂ffnen wenn nicht automatisch generiert
    if (!autoGenerated) {
      const { data: urlData } = supabase.storage
        .from('documents')
        .getPublicUrl(filePath)
      
      window.open(urlData.publicUrl, '_blank')
    }

    console.log("üéâ PDF-Generierung erfolgreich abgeschlossen")
    return { success: true, filePath }

  } catch (error: any) {
    console.error('‚ùå Fehler beim PDF-Export:', error)
    return { success: false, error: error.message }
  }
}

// Stats aus Transaktionen berechnen
export function calculateDailyStats(
  transactions: TransactionItem[],
  startingCash: number = 0
): DailyStatsData {
  const completedTransactions = transactions.filter(t => t.status === 'completed')
  
  const cash = completedTransactions
    .filter(t => t.method === 'cash')
    .reduce((sum, t) => sum + t.amount, 0)
  
  const twint = completedTransactions
    .filter(t => t.method === 'twint')
    .reduce((sum, t) => sum + t.amount, 0)
  
  const sumup = completedTransactions
    .filter(t => t.method === 'sumup')
    .reduce((sum, t) => sum + t.amount, 0)
  
  const total = cash + twint + sumup
  const endingCash = startingCash + cash

  return {
    cash,
    twint,
    sumup,
    total,
    startingCash,
    endingCash,
    transactionCount: completedTransactions.length
  }
}

// Transaktionen aus Sales formatieren
export function formatTransactionsFromSales(sales: any[]): TransactionItem[] {
  return sales.map(sale => ({
    id: sale.id,
    time: formatTimeForDisplay(sale.created_at),
    amount: sale.total_amount,
    method: sale.payment_method,
    status: sale.status
  }))
}

// Datum-Utilities
export function getCurrentDateString(): string {
  return new Date().toISOString().split('T')[0]
}

export function getDateString(date: Date): string {
  return date.toISOString().split('T')[0]
}