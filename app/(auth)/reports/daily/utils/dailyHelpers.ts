import { pdf } from '@react-pdf/renderer'
import { supabase } from '@/lib/supabase/client'
import { formatDateForAPI, formatDateForDisplay, formatTimeForDisplay } from '@/lib/utils/dateUtils'
import type { DailySummary, TransactionItem, DailyStatsData } from './dailyTypes'

// PDF-Generierung fÃ¼r Daily Reports (modernized)
export async function generateDailyReportPDF(
  summary: DailySummary,
  transactions: TransactionItem[],
  autoGenerated = false
): Promise<{ success: boolean; error?: string; filePath?: string }> {
  console.log("ðŸ”§ generateDailyReportPDF gestartet", { 
    summaryId: summary.id, 
    autoGenerated, 
    transactionCount: transactions.length 
  })
  
  try {
    // Import React and DailyReportPDF component dynamically
    const React = await import('react')
    const { DailyReportPDF } = await import('@/components/pdf/DailyReportPDF')
    
    // Generate PDF blob
    console.log("ðŸ“„ Generiere PDF...")
    const pdfComponent = React.createElement(DailyReportPDF, { summary, transactions }) as React.ReactElement<any>
    const blob = await pdf(pdfComponent).toBlob()
    
    // Create file for upload
    const fileName = `tagesabschluss-${summary.report_date}.pdf`
    const file = new File([blob], fileName, { type: 'application/pdf' })
    
    // Upload to Supabase Storage
    const filePath = `documents/daily_reports/${fileName}`
    console.log("â˜ï¸ Lade PDF zu Storage hoch:", filePath)
    
    const { error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: true // Ãœberschreiben falls bereits vorhanden
      })
      
    if (uploadError) {
      console.error('âŒ Upload-Fehler:', uploadError)
      throw uploadError
    }

    // Create document record in database
    console.log("ðŸ—ƒï¸ Erstelle Dokument-Eintrag...")
    const { data: userData } = await supabase.auth.getUser()
    if (userData?.user) {
      const documentData = {
        type: 'daily_report' as const,
        reference_id: summary.id,
        file_path: filePath,
        payment_method: null,
        document_date: summary.report_date,
        user_id: userData.user.id
      }
      
      const { error: documentError } = await supabase
        .from('documents')
        .upsert(documentData)
      
      if (documentError) {
        console.error('âŒ Fehler beim Erstellen des Dokumenteneintrags:', documentError)
      } else {
        console.log("âœ… Dokument-Eintrag erfolgreich erstellt")
      }
    }

    // Open PDF if not auto-generated
    if (!autoGenerated) {
      const { data: urlData } = supabase.storage
        .from('documents')
        .getPublicUrl(filePath)
      
      window.open(urlData.publicUrl, '_blank')
    }
    
    console.log("ðŸŽ‰ PDF-Generierung erfolgreich abgeschlossen")
    return { success: true, filePath }

  } catch (error: any) {
    console.error('âŒ Fehler beim PDF-Export:', error)
    return { success: false, error: error.message }
  }
}

// Stats aus Transaktionen berechnen
export function calculateDailyStats(
  transactions: TransactionItem[],
  startingCash: number = 0
): DailyStatsData {
  const completedTransactions = transactions.filter(t => t.status === 'completed')
  
  const cash = completedTransactions
    .filter(t => t.method === 'cash')
    .reduce((sum, t) => sum + t.amount, 0)
  
  const twint = completedTransactions
    .filter(t => t.method === 'twint')
    .reduce((sum, t) => sum + t.amount, 0)
  
  const sumup = completedTransactions
    .filter(t => t.method === 'sumup')
    .reduce((sum, t) => sum + t.amount, 0)
  
  const total = cash + twint + sumup
  const endingCash = startingCash + cash

  return {
    cash,
    twint,
    sumup,
    total,
    startingCash,
    endingCash,
    transactionCount: completedTransactions.length
  }
}

// Transaktionen aus Sales formatieren
export function formatTransactionsFromSales(sales: any[]): TransactionItem[] {
  return sales.map(sale => ({
    id: sale.id,
    time: formatTimeForDisplay(sale.created_at),
    amount: sale.total_amount,
    method: sale.payment_method,
    status: sale.status
  }))
}

// Datum-Utilities
export function getCurrentDateString(): string {
  return formatDateForAPI(new Date())
}

export function getDateString(date: Date): string {
  return formatDateForAPI(date)
}