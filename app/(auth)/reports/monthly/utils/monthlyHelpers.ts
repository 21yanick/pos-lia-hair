import { PDFDocument, StandardFonts, rgb } from 'pdf-lib'
import { supabase } from '@/lib/supabase/client'
import type { TransactionItem } from '../components/TransactionsList'
import type { MonthlyStatsData } from '../components/MonthlyStats'
import type { ExportType } from '../components/ExportButtons'

export type ExportData = {
  type: ExportType
  label: string
  transactions: TransactionItem[]
  stats: MonthlyStatsData
  selectedMonth: string
  total: number
}

// Hilfsfunktion: Aktueller Monat/Jahr formatiert
export function getCurrentYearMonth(): string {
  const now = new Date()
  const year = now.getFullYear()
  const month = now.getMonth() + 1
  return `${year}-${month.toString().padStart(2, '0')}`
}

// Hilfsfunktion: Monatsoptionen f√ºr Dropdown
export function getMonthOptions() {
  const options = []
  const currentDate = new Date()
  
  // Die letzten 12 Monate
  for (let i = 0; i < 12; i++) {
    const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1)
    const year = date.getFullYear()
    const month = date.getMonth() + 1
    const value = `${year}-${month.toString().padStart(2, '0')}`
    const label = date.toLocaleDateString("de-CH", { month: "long", year: "numeric" })
    options.push({ value, label })
  }
  
  return options
}

// Hilfsfunktion: Formatiertes Datum f√ºr Anzeige
export function formatMonthYear(yearMonth: string): string {
  const [year, month] = yearMonth.split('-').map(Number)
  return new Date(year, month - 1, 1).toLocaleDateString("de-CH", { 
    month: "long", 
    year: "numeric"
  })
}

// CSV Export
export function exportToCSV(data: ExportData): void {
  const { type, label, transactions, selectedMonth } = data
  
  let csvContent = `${label} - ${formatMonthYear(selectedMonth)}\n`
  csvContent += `Exportiert am: ${new Date().toLocaleDateString('de-CH')}\n\n`
  
  // Header je nach Export-Typ
  if (type === 'complete_month') {
    csvContent += 'Datum,Typ,Beschreibung,Bar,TWINT,SumUp,Total,Status\n'
  } else if (type.startsWith('revenue_')) {
    csvContent += 'Datum,Beschreibung,Betrag,Status\n'
  } else {
    csvContent += 'Datum,Kategorie,Beschreibung,Betrag,Zahlungsart\n'
  }
  
  // Daten hinzuf√ºgen
  transactions.forEach(transaction => {
    const date = new Date(transaction.date).toLocaleDateString('de-CH')
    
    if (type === 'complete_month') {
      const sign = transaction.type === 'daily_report' ? '' : '-'
      csvContent += `${date},"${transaction.type === 'daily_report' ? 'Tagesabschluss' : 'Ausgabe'}","${transaction.description}",${transaction.cash || 0},${transaction.twint || 0},${transaction.sumup || 0},${sign}${transaction.total},${transaction.status || ''}\n`
    } else if (type.startsWith('revenue_')) {
      const amount = type === 'revenue_cash' ? transaction.cash : 
                   type === 'revenue_twint' ? transaction.twint : 
                   transaction.sumup
      csvContent += `${date},"${transaction.description}",${amount},${transaction.status}\n`
    } else {
      csvContent += `${date},"${transaction.category || 'Ausgabe'}","${transaction.description}",${transaction.total},"${transaction.paymentMethod === 'cash' ? 'Bar' : 'Bank'}"\n`
    }
  })
  
  // CSV-Datei herunterladen
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  const url = window.URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `${label.toLowerCase().replace(/\s+/g, '_')}_${selectedMonth}.csv`
  a.click()
  window.URL.revokeObjectURL(url)
}

// PDF Export f√ºr kompletten Monat
export async function exportMonthlyPDF(
  stats: MonthlyStatsData,
  transactions: TransactionItem[],
  selectedMonth: string,
  autoGenerated = false
): Promise<void> {
  const pdfDoc = await PDFDocument.create()
  const page = pdfDoc.addPage([595.28, 841.89]) // A4
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica)
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold)
  
  const { width, height } = page.getSize()
  const fontSize = 12
  const padding = 50
  let yPos = height - padding

  // Titel
  page.drawText('MONATSABSCHLUSS', {
    x: padding,
    y: yPos,
    size: 24,
    font: boldFont,
    color: rgb(0, 0, 0),
  })
  yPos -= 40

  // Monat/Jahr
  page.drawText(`${formatMonthYear(selectedMonth)}`, {
    x: padding,
    y: yPos,
    size: fontSize + 2,
    font: boldFont,
    color: rgb(0, 0, 0),
  })
  yPos -= 40

  // SALON-UMS√ÑTZE
  page.drawText('SALON-UMS√ÑTZE', {
    x: padding,
    y: yPos,
    size: fontSize + 2,
    font: boldFont,
    color: rgb(0, 0.5, 0),
  })
  yPos -= 25

  page.drawText(`Bar:     CHF ${stats.salesCash.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize,
    font,
    color: rgb(0, 0, 0),
  })
  yPos -= 18

  page.drawText(`TWINT:   CHF ${stats.salesTwint.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize,
    font,
    color: rgb(0, 0, 0),
  })
  yPos -= 18

  page.drawText(`SumUp:   CHF ${stats.salesSumup.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize,
    font,
    color: rgb(0, 0, 0),
  })
  yPos -= 25

  page.drawText(`TOTAL:   CHF ${stats.salesTotal.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize + 1,
    font: boldFont,
    color: rgb(0, 0.5, 0),
  })
  yPos -= 40

  // AUSGABEN
  page.drawText('AUSGABEN', {
    x: padding,
    y: yPos,
    size: fontSize + 2,
    font: boldFont,
    color: rgb(0.8, 0, 0),
  })
  yPos -= 25

  page.drawText(`Bar:     CHF ${stats.expensesCash.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize,
    font,
    color: rgb(0, 0, 0),
  })
  yPos -= 18

  page.drawText(`Bank:    CHF ${stats.expensesBank.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize,
    font,
    color: rgb(0, 0, 0),
  })
  yPos -= 25

  page.drawText(`TOTAL:   CHF ${stats.expensesTotal.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize + 1,
    font: boldFont,
    color: rgb(0.8, 0, 0),
  })
  yPos -= 40

  // STATISTIKEN
  page.drawText('STATISTIKEN', {
    x: padding,
    y: yPos,
    size: fontSize + 2,
    font: boldFont,
    color: rgb(0, 0, 0),
  })
  yPos -= 25

  page.drawText(`Tage mit Umsatz: ${stats.transactionDays} von ${stats.daysInMonth}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize,
    font,
    color: rgb(0, 0, 0),
  })
  yPos -= 18

  page.drawText(`√ò Tagesumsatz: CHF ${stats.avgDailyRevenue.toFixed(2)}`, {
    x: padding + 20,
    y: yPos,
    size: fontSize,
    font,
    color: rgb(0, 0, 0),
  })
  yPos -= 35

  // CHRONOLOGISCHE TRANSAKTIONEN (erste 20)
  if (transactions.length > 0) {
    page.drawText('CHRONOLOGISCHE TRANSAKTIONEN', {
      x: padding,
      y: yPos,
      size: fontSize + 2,
      font: boldFont,
      color: rgb(0, 0, 0),
    })
    yPos -= 25

    const sortedTransactions = [...transactions]
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
      .slice(0, 20)

    sortedTransactions.forEach((transaction) => {
      if (yPos < 100) return // Avoid overflow

      const date = new Date(transaction.date).toLocaleDateString('de-CH')
      const sign = transaction.type === 'daily_report' ? '+' : '-'
      const type = transaction.type === 'daily_report' ? 'Tagesabschluss' : 'Ausgabe'
      
      page.drawText(`${date} | ${type} | CHF ${sign}${transaction.total.toFixed(2)}`, {
        x: padding + 20,
        y: yPos,
        size: fontSize - 1,
        font,
        color: transaction.type === 'daily_report' ? rgb(0, 0.5, 0) : rgb(0.8, 0, 0),
      })
      yPos -= 16
    })
  }

  // Footer
  page.drawText(`Erstellt am: ${new Date().toLocaleDateString('de-CH')} um ${new Date().toLocaleTimeString('de-CH')}`, {
    x: padding,
    y: 50,
    size: fontSize - 2,
    font,
    color: rgb(0.5, 0.5, 0.5),
  })

  // PDF speichern und in Storage/Documents integrieren
  console.log("üîß Monthly PDF speichern gestartet f√ºr:", selectedMonth)
  const pdfBytes = await pdfDoc.save()
  const fileName = `monatsabschluss-${selectedMonth}.pdf`
  console.log("üìÑ Monthly PDF erstellt:", fileName)

  try {
    // Als Datei f√ºr Storage vorbereiten
    const file = new File([pdfBytes], fileName, { type: 'application/pdf' })
    
    // Datei zu Supabase Storage hochladen
    const filePath = `documents/monthly_reports/${fileName}`
    console.log("‚òÅÔ∏è Lade Monthly PDF zu Storage hoch:", filePath)
    
    const { error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: true // √úberschreiben falls bereits vorhanden
      })
      
    if (uploadError) {
      console.error('‚ùå Fehler beim Hochladen der Monthly PDF:', uploadError)
      // Fallback: Direkter Download ohne Storage
      const blob = new Blob([pdfBytes], { type: 'application/pdf' })
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = fileName
      a.click()
      window.URL.revokeObjectURL(url)
      return
    }

    // Dokument-Eintrag in der Datenbank erstellen
    console.log("üóÉÔ∏è Erstelle Monthly Document-Eintrag...")
    const { data: userData } = await supabase.auth.getUser()
    if (userData?.user) {
      // Monthly Summary ID finden f√ºr reference_id
      const monthDate = `${selectedMonth}-01` // Ersten Tag des Monats als Referenz
      
      // UUID f√ºr Monthly Report generieren (da reference_id UUID sein muss)
      const monthlyUUID = crypto.randomUUID()
      
      const documentData = {
        type: 'monthly_report' as const,
        reference_id: monthlyUUID, // Generierte UUID f√ºr Monthly Reports
        file_path: filePath,
        payment_method: null,
        document_date: monthDate,
        user_id: userData.user.id
      }
      console.log("üìù Monthly Document-Daten:", documentData)
      
      const { error: documentError } = await supabase
        .from('documents')
        .upsert(documentData)
      
      if (documentError) {
        console.error('‚ùå Fehler beim Erstellen des Monthly Document-Eintrags:', documentError)
        console.error('‚ùå Fehlerdetails:', JSON.stringify(documentError, null, 2))
        console.error('‚ùå Versuchte Daten:', JSON.stringify(documentData, null, 2))
      } else {
        console.log("‚úÖ Monthly Document-Eintrag erfolgreich erstellt")
      }
    } else {
      console.error("‚ùå Kein User f√ºr Monthly Document gefunden")
    }

    // PDF nur √∂ffnen wenn nicht automatisch generiert
    if (!autoGenerated) {
      console.log("üåê √ñffne Monthly PDF...")
      const { data: urlData } = supabase.storage
        .from('documents')
        .getPublicUrl(filePath)
      
      window.open(urlData.publicUrl, '_blank')
      console.log("üéâ Monthly PDF erfolgreich erstellt und ge√∂ffnet")
    } else {
      console.log("üéâ Monthly PDF automatisch erstellt und gespeichert")
    }
    
  } catch (error: any) {
    console.error('‚ùå Fehler beim Speichern der Monthly PDF:', error)
    // Fallback: Direkter Download
    const blob = new Blob([pdfBytes], { type: 'application/pdf' })
    const url = window.URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = fileName
    a.click()
    window.URL.revokeObjectURL(url)
  }
}

// Hauptexport-Funktion
export async function handleExport(data: ExportData): Promise<void> {
  const { type } = data
  
  if (type === 'complete_month') {
    // F√ºr kompletten Monat PDF erstellen
    await exportMonthlyPDF(data.stats, data.transactions, data.selectedMonth)
  } else {
    // F√ºr spezifische Exports CSV erstellen
    exportToCSV(data)
  }
}